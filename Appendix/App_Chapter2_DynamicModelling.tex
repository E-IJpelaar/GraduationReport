\section{Inverse kinematics}
\label{app:chap2}

%This subsection is not definite. 2 inverse kinematic scripts have been created. One in which only end-effector position $[x,y]$ is given. One where also the orientation is added $[x,y,\theta]$ . For only a single shape-function approximation (constant curvature approach), will find the shortest path. However, when increasing the amount of shape functions, both models will not come with the most shortest path. Therefore, the inverse kinematics as described here has not been used extensively.


Inverse kinematics allows to map the desired end-effector position to the corresponding modal coordinates. To determine this inverse mapping the Jacobian search method is exploited \cite{JacobianInverse}. Essentially, a desired position and orientation of the robot's end-effector is given. The derived forward kinematics can be regarded as,

\begin{equation}
    x = f(q),
\end{equation}

where, $x \in \mathbb{R}^n$ is the position and orientation vector of the end-effector. For the planar robot $n = 3$, as two translations and one coupled rotation can be achieved. Here, $f$ represents the forward kinematics mapping the modal coordinate $q \in \mathbb{R}^m$ to the end-effector position. Where $m$ depends on amount of shape functions used to describe a given strain. The inverse kinematic problem aims to find a mapping $q\mapsto x$. This mapping is obtained by exploiting the inverse jacobian method according to an iterative updating scheme as,

\begin{equation}
    q_{k+1} = q_k + \alpha [J(\sigma,t)]_1^\dagger Q e_k \hspace{20pt} \text{with} \hspace{10pt}  e_k = x_d - x_k,
    \label{eq2:qupdate}
\end{equation}

where $q_k$ is modal coordinate vector at iteration $k$, $\alpha > 0$ a learning gain to enhance fast convergence $Q \in \mathbb{R}^{n\times n}$ is a diagonal matrix used to prioritize desired end-effector coordinates. In our case, the position is prioritized over the orientation. Lastly, $J^\dagger$ is an adapted form of the damped Mooreâ€“Penrose pseudo inverse defined as,

\begin{equation}
    J^\dagger = WJ^\top(JWJ^\top + \rho^2 I)^{-1}
    \label{eq2:pseudoinverse},
\end{equation}

where $W \in \mathbb{R}^{m\times m}$ is a diagonal weighing matrix that can be used to stress lower order shape functions. Put in other words, the algorithm aims to achieve the same error norm while prioritizing modal coordinates belonging to lower order shape functions. This can be used to decide on the amount of shape functions used in approximation. The factor $\rho^2 I \in \mathbb{R}^{6 \times 6}$ is introduced to avoid singularities of the jacobian matrix $J \in \mathbb{R}^{6 \times m}$. 

An algorithm capable of finding a inverse kinematic solution is created based on Equation (\ref{eq2:qupdate}). The algorithm is initiated with a desired end-effector position $x_d$ and guess for modal coordinates $q_0$. Furthermore, the amount of shape functions used to approximate the end-effector position is user defined. This results in,


\begin{algorithm}[H]
\caption{Numerical Inverse Kinematics}
\begin{algorithmic}[1]
\State $q$ $\leftarrow$ $q_0$ \Comment{Initial condition}
\While{$|| x_d - x_k || > \epsilon$}{}      \Comment{While error is larger than some $\epsilon$}
    \State $x_k$ $\leftarrow$ $f(q_k)$  \Comment{Position at current generalized coordinate}
     \State $e_k$ $\leftarrow$ $x_k - x_d$ \Comment{Current error}
        \For{$0:\Delta \sigma:L$}
            \State $J_{\sigma}$ $\leftarrow$  $J_{\sigma}$ + $Ad_{g(\Delta \sigma)} B_a \Phi(\Delta \sigma)$ \Comment{Numerical integration over length L}
        \EndFor
    \State \textbf{end}
    \State $J$ $\leftarrow$ $Ad_{g^{-1},\sigma=L}$ $J_{\sigma}$ \Comment{Compute Jacobian}
    \State $J^{\dagger}$ $\leftarrow$  $w$ $J^{\top}$ $(J^\top w J - \rho \mathbb{I}_6)^{-1}$ \Comment{Calculate pseudo inverse}
    \State $q_{k+1}$  $\leftarrow$ $q_{k}$ + $\alpha$ $J^{\dagger} \beta e_k$ \Comment{Update generalized coordinates}
\EndWhile 
\State \textbf{end}
    \label{alg2:numericalinverse}
\end{algorithmic}
\end{algorithm}


\section{Velocity kinematics}


Using the equality of mixed partial derivatives, at each instant of space and time $\frac{\partial}{\partial t}g' = \frac{\partial}{\partial \sigma}\dot{g}$ holds \cite{Caasenbrood2020}. Substituting (\ref{eq2:dgdsigma}) and (\ref{eq2:dgdt}) into this relation and simplifying results in,

\begin{equation}
    \hat{\eta}' = -(\hat{\xi}\hat{\eta} - \hat{\eta}\hat{\xi}) + \Dot{\xi},
        \label{eq2:pde2}
\end{equation}

here the Lie bracket $\xi$ and $\eta$ can be recognized between the parenthesis. The Lie bracket $[\hat{\xi},\hat{\eta}]$ also belongs to the group of Lie algebra $\mathfrak{se}(3)$. Therefore, it can be expressed by the adjoint action between $\xi$ onto $\eta$. This adjoint action maps the PDE of (\ref{eq2:pde2}) from $\mathbb{R}^{6\times 6}$ to $\mathbb{R}^6$. This allows to write the velocity kinematics in vector notation as,

\begin{equation}
    \eta'= -\text{ad}_\xi \eta + \Dot{\xi} \hspace{10pt} \text{with} \hspace{10pt} \text{ad}_{\xi} = \begin{bmatrix} K_\times & 0_{3\times 3} \\ E_\times & K_\times \end{bmatrix}.
    \label{eq2:etapde}
\end{equation}


Exploiting the relation $\frac{d}{d \sigma} \text{Ad}_g = \text{Ad}_g \text{ad}_{g^{-1}g'}$ \cite{Boyer2019}, \cite{traversaro2016multibody} , with $g^{-1}g' = \xi$ which follows from (\ref{eq2:dgdsigma}), it follows that $-\text{ad}_\xi = (\text{Ad}_g^{-1})'\text{Ad}_g$. Substitution of this expression into (\ref{eq2:etapde}) allows to formulate the spatial derivative of the velocity twist as,

\begin{equation}
    \eta'= (\text{Ad}_g^{-1})'\text{Ad}_g \eta + \Dot{\xi} \hspace{10pt} \text{with} \hspace{10pt} \text{Ad}_g = \begin{bmatrix} R & 0_{3\times 3} \\ p_\times R & R \end{bmatrix}
    \label{eq2app:etadif}
\end{equation}

where $\text{Ad}_g \in \mathbb{R}^{6 \times 6}$ and $\text{Ad}_{g^{-1}}  \in \mathbb{R}^{6 \times 6}$ are the adjoint and inverse adjoint mapping of $g$, respectively \cite{Sola2018}. An analytic solution can be found by integrating (\ref{eq2app:etadif}) over spatial domain $[0,\sigma]$. However, solving PDE's is generally more computationally expensive and makes controller design hard.
To overcome this, the theoretical infinite dimensional system is projected onto a finite dimensional subspace. In order to do so, we assume the following.
